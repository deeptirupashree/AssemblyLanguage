;DEEPTI SAHU

; A PROC WHICH WILL SET N ELEMENTS OF AN UNSIGNED WORD ARRAY ELEMENTS TO 0
; PARAMETERS ARE NUMBER OF UNSIGNED WORD ARRAY ELEMENTS AS A VALUE PARAMETER
; ARRAY ADDRESSES
; A PROC WHICH WILL COUNT THE NUMBER OF TIMES EACH UPPER CASE LETTER APPEARS
; IN A STRING
; A PROC WHICH WILL PRINT OUT A LETTER AND THE APPROPRIATE COUNTER FOR A GIVEN CASE
; 8 VALUES PER LINE
; A PROC WHICH WILL ADD ELEMENTS OF ONE ARRAY TO CORRESPONDING ELEMENTS OF A SECOND ARRAY
; A MACRO WHICH WILL PROMPT FOR A STRING, INPUT THE STRING AND GO TO A NEW LINE
; CALL THE INITIALIZATION PROC FOR EACH OF THE ARRAYS USED FOR SUM OF ALL STRINGS.
; THEN REPEAT THE FOLLOWING STEPS UNTIL THE MACRO INPUTS A NULL STRING
; CALL THE INITIALIZATION PROC FOR EACH ARRAY USED
; CALL THE COUNTING PROC
; CALL THE PRINTING PROC FOR EACH ARRAY USED FOR THE CURRENT STRING
; CALL THE SUM PROC FOR EACH APPROPRIATE PAIR OF ARRAYS
; CALL THE PRINTING PROC FOR EACH ARRAY USED FOR THE SUMS

.MODEL SMALL
.586
.STACK 256
  INCLUDE CIS21JA.INC

  CR  EQU 13
  LF  EQU 10
  S_SIZE EQU 50
  INT_SIZE EQU 8
  ARR_SIZE EQU 26


  .CONST
  PROMPT1    BYTE "ENTER A STRING",CR,LF,"$"
  CRLF        BYTE  CR,LF,'$'


.DATA
;INPUT STRING
ININFO_S  LABEL BYTE
MAX_LEN      BYTE S_SIZE
ACT_LEN  BYTE ?
S_ARRAY  BYTE S_SIZE DUP(?)

;OUTPUT STRING
OUT_ARRAY  BYTE 8 DUP(?)
          BYTE '$'

LOWERCUR  WORD ARR_SIZE DUP(?)
UPPERCUR  WORD ARR_SIZE DUP(?)
LOWERSUM  WORD ARR_SIZE DUP(?)
UPPERSUM  WORD ARR_SIZE DUP(?)


.CODE

START :
      MOV    AX,@DATA
      MOV    DS,AX

    PRINTSTR MACRO PROMPTSTR,INPUTSTR,NEWLINE
      ;PRMPT A STRING
      MOV    AH,09H
      LEA    DX,PROMPTSTR
      INT    21H

      MOV    AH,0A
      LEA    DX,INPUTSTR
      INT    21H

              ;GO TO NEW LINE
      MOV    AH,09H
      LEA    DX,NEWLINE
      INT    21H
ENDM
PUSH  ARR_SIZE        ;PUSH THE LENGTH OF THE INPUT STRING
PUSH  OFFSET LOWERSUM
CALL INITIALIZE
PUSH  ARR_SIZE        ;PUSH THE LENGTH OF THE INPUT STRING
PUSH  OFFSET UPPERSUM
CALL INITIALIZE

TOP:
;CALL MACRO
  PRINTSTR PROMPT1,ININFO_S,CRLF
  CMP ACT_LEN,0;EXIT IF INPUT NULL
  JE DONE

;CALL INITIALIZE
  PUSH  ARR_SIZE        ;INITIAL ARRAY
  PUSH  OFFSET LOWERCUR
  CALL INITIALIZE
  PUSH  ARR_SIZE        ;INITIAL ARRAY
  PUSH  OFFSET UPPERCUR
  CALL INITIALIZE

  ;CALL COUNT
  MOVZX AX,ACT_LEN
  PUSH  AX
  PUSH OFFSET S_ARRAY
  PUSH OFFSET UPPERCUR
  PUSH OFFSET LOWERCUR
  CALL COUNTCHAR ;give number to upper and lower array

  ;CALL PRINTOUT
  MOV AL,'A'
  MOVZX AX,AL
  PUSH AX
  PUSH OFFSET UPPERCUR
  PUSH OFFSET OUT_ARRAY
  CALL PRINTOUT

  MOV AH,09H
  MOV DX,OFFSET CRLF
  INT 21H

  MOV AL,'a'
  MOVZX AX,AL
  PUSH AX
  PUSH OFFSET LOWERCUR
  PUSH OFFSET OUT_ARRAY
  CALL PRINTOUT
  MOV AH,09H
  MOV DX,OFFSET CRLF
  INT 21H
  ;CALL SUM
  MOV BX,26
  PUSH BX
  PUSH OFFSET UPPERCUR
  PUSH OFFSET UPPERSUM
  CALL SUM
  PUSH BX
  PUSH OFFSET LOWERCUR
  PUSH OFFSET LOWERSUM
  CALL SUM
  JMP TOP
  DONE:
  MOV AL,'A'
  MOVZX AX,AL
  PUSH AX
  PUSH OFFSET UPPERSUM
  PUSH OFFSET OUT_ARRAY
  CALL PRINTOUT
  MOV AL,'a'
  MOVZX AX,AL
  PUSH AX
  PUSH OFFSET LOWERSUM
  PUSH OFFSET OUT_ARRAY
  CALL PRINTOUT
  ;EXIT PROGRAM
  MOV AH,4CH
  INT 21H

;SUM PROCEDURE
SUM PROC NEAR
PUSH BP
MOV BP,SP
PUSH DI
PUSH CX
MOV CX,[BP+8]
MOV DI,[BP+4]
MOV SI,[BP+6]

NEXTONE:
MOV AX,WORD PTR[SI]
ADD WORD PTR[DI],AX
ADD DI,2
ADD SI,2
LOOP NEXTONE

POP CX
POP DI
POP BP

RET 6
SUM ENDP

;PRINT OUT LETTER
PRINTOUT PROC NEAR
PUSH BP
MOV BP,SP
PUSH SI
PUSH DX
PUSH CX
MOV  CX,26
MOV SI,[BP+6] ;UPPER OR LOWER
MOV BL,[BP+8]

  NEXTARR:
  MOV DL,BL;print letter
  MOV AH,02H
  INT 21H

  MOV DL,'=';print letter
  MOV AH,02H
  INT 21H

  INVOKE  $UW2ASC,[SI],[BP+4],INT_SIZE,' '
  MOV DX,[BP+4]
  MOV AH,09H
  INT 21H

  MOV DL,09;print letter
  MOV AH,02H
  INT 21H

  INC BL
  ADD SI,2 ;NEXT INDEX
LOOP NEXTARR

POP CX
POP DX
POP SI
POP BP
RET 6

PRINTOUT ENDP

;COUNT THE NUMBER OF TIMES
COUNTCHAR PROC NEAR ;STRLEN,STR ADDRESS,UPPER,LOWER
PUSH BP
MOV BP,SP
PUSH CX ;FOR STRING LENGTH
PUSH BX
PUSH SI ;UPPER OR LOWER STRING
MOV DI,[BP+8];INDEX FOR STRING
MOV  CX,[BP+10] ;STRING LENGTH


LOOPCHAR: ;LOOP STRING
CMP BYTE PTR[DI],'A';UPPERCASE DI>A && DI<Z
JNAE NEXTINDEX
CMP BYTE PTR[DI],'Z';UPPERCASE DI>A && DI<Z
JNBE LOWER

;UPPERCASE
MOV BL,BYTE PTR[DI]
SUB BL,'A'
ADD BL,BL
MOVZX BX,BL
ADD BX,[BP+6]
INC WORD PTR[BX]


JMP NEXTINDEX
;LOWERCASE
LOWER: ;DI>a&&DI<z
CMP BYTE PTR[DI],'a';SKIP OTHER SIGN
JB NEXTINDEX
CMP BYTE PTR[DI],'z'
JA NEXTINDEX

; LOWERCASE
MOV BL,BYTE PTR[DI]
SUB BL,'a'
ADD BL,BL
MOVZX BX,BL
ADD BX,[BP+4]
INC WORD PTR[BX]

NEXTINDEX:
INC DI ;NEXT INPUT ARRAY
LOOP LOOPCHAR

POP DI
POP BX
POP CX
POP BP
RET 8
COUNTCHAR ENDP

;INITIALIZE ARRAY WITH 0
  INITIALIZE PROC NEAR ; PASS LENGTH,ARRAY
  PUSH BP
  MOV  BP,SP
  PUSH CX
  PUSH DI
  MOV  CX,[BP+6];LENGTH OF STRING CX
  MOV  DI,[BP+4];ARRAY ADDRESS

  NEXT_CHAR:
  MOV WORD PTR[DI],0  ;GIVE VALUE TO 0
  ADD DI,1  ;INCREASE ARRAY INDEX
  LOOP NEXT_CHAR
    POP DI
    POP CX
    POP BP
    RET  4
INITIALIZE ENDP

      END START

